/**
 * @fileoverview Firestore Security Rules for ComponentCompares application.
 *
 * Core Philosophy:
 * This ruleset prioritizes strong authorization based on user roles (superuser) and ownership,
 * while maintaining flexibility in data shapes for rapid prototyping.  Schema validation is minimal.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profiles. Document ID matches Firebase Auth UID.
 * - /users/{userId}/sales/{saleId}: Stores sales records for a specific user.
 * - /products/{productId}: Stores product information.
 * - /sales/{saleId}: Stores all sales globally.
 * - /audit_logs/{auditLogId}: Stores audit logs.
 *
 * Key Security Decisions:
 * - Superusers can manage all products, sales, and audit logs.
 * - Regular users can only manage their own user profiles and sales records under their profile.
 * - Public read access to products is not enabled in this initial security setup.
 *
 * Denormalization for Authorization:
 * - User roles are checked using a global helper function `isSuperuser()`.  In a production
 *   environment, this might require denormalizing the role onto the user document or using
 *   a custom claim.
 *
 * Structural Segregation:
 * - Sales data is stored both under the user's profile and in a top-level collection for
 *   superuser access.  This avoids complex querying and authorization logic.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the user is signed in.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user's UID matches the provided userId.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user is a superuser.
     * @note This is a placeholder.  In a real application, you would likely implement
     *       this by checking a custom claim or reading the user's role from their document.
     */
    function isSuperuser() {
      // In a real implementation, check for a custom claim or role in user document.
      return false;
    }

    /**
     * @description Checks if the authenticated user is the owner of the existing document
     */
    function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
    }


    /**
     * @description Rules for user profiles.
     * @path /users/{userId}
     * @allow (create) User 'alice' with UID 'alice' can create her profile.
     * @allow (get) User 'bob' with UID 'bob' can read his profile.
     * @deny (create) User 'alice' with UID 'alice' cannot create user profile 'bob' with UID 'bob'.
     * @deny (get) User 'alice' with UID 'alice' cannot read user profile 'bob' with UID 'bob'.
     * @principle Enforces document ownership for writes and reads.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id; // Immutable ID check
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for sales records under a user's profile.
     * @path /users/{userId}/sales/{saleId}
     * @allow (create) User 'alice' can create a sale record under her profile.
     * @allow (get) User 'alice' can read a sale record under her profile.
     * @deny (create) User 'alice' cannot create a sale record under 'bob's profile.
     * @deny (delete) User 'bob' cannot delete 'alice's sale record.
     * @principle Enforces document ownership for writes and reads within a user's data tree.
     */
    match /users/{userId}/sales/{saleId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for products.
     * @path /products/{productId}
     * @allow (create) A superuser can create a product.
     * @allow (get) Any user can read a product.
     * @deny (create) A regular user cannot create a product.
     * @deny (delete) A regular user cannot delete a product.
     * @principle Restricts product management to superusers.
     */
    match /products/{productId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSuperuser();
      allow update: if isSuperuser() && resource != null;
      allow delete: if isSuperuser() && resource != null;
    }

    /**
     * @description Rules for global sales records.
     * @path /sales/{saleId}
     * @allow (create) A superuser can create a sale record.
     * @allow (get) A superuser can read a sale record.
     * @deny (create) A regular user cannot create a sale record in the global collection.
     */
    match /sales/{saleId} {
      allow get: if isSuperuser();
      allow list: if isSuperuser();
      allow create: if isSuperuser();
      allow update: if isSuperuser() && resource != null;
      allow delete: if isSuperuser() && resource != null;
    }

    /**
     * @description Rules for audit logs.
     * @path /audit_logs/{auditLogId}
     * @allow (create) A superuser can create an audit log.
     * @allow (get) A superuser can read an audit log.
     * @deny (create) A regular user cannot create an audit log.
     */
    match /audit_logs/{auditLogId} {
      allow get: if isSuperuser();
      allow list: if isSuperuser();
      allow create: if isSuperuser();
      allow update: if isSuperuser() && resource != null;
      allow delete: if isSuperuser() && resource != null;
    }
  }
}